第六章 查找
折半查找
#include <stdio.h>
int search(int a[],int key);
int main()
{
    int array[] = {1,2,3,4,5,6,7,8,9,10,21,22,23,24,25,26,27,28,29,80,100};
    int a;
    while(scanf("%d",&a) !=EOF){
        int flag = search(array,a);
        if(flag>-1)
        {
            printf("The number's pos is %d\n",flag);
        }else{
            printf("not exit\n");
        }
    }
    return 0;

}
int search(int a[],int key){
    int low = 0, high =20, mid;
    while(low<=high){
        mid = (low+high)/2;
        if(a[mid] == key)
            return mid;
        else if(a[mid]<key)
            low = mid+1;
        else
            high = mid-1;
    }
    return -1;
}

寻找子串
#include <stdio.h>
#include <string>
#include <iostream>
using namespace std;

int main()
{
    string s = "askdjfklabcdeabjasdkflasjk";
    string sub = "abcde";
    int i = 0;
    int j = 0;
    while(i<s.length() && j<sub.length())
    {
        if(s[i] == sub[j]){
            i++;
            j++;
        }
        else
        {
            i = i-j+1; j=0;
        }
    }
    if(j==sub.length())
        cout<<i-j<<endl;
    else
        cout<<"not found"<<endl;
}


第七章 排序
#include <stdio.h>
void sort1(int a[]);
void sort2(int a[]);
void sort3(int a[]);
void sort4(int a[]);
void sort5(int a[],int low,int high);
void sort6(int a[]);
void sort7(int a[],int length);
void swap(int &a,int &b)
{
    int c = a;
    a = b;
    b = c;
}
int main()
{
    /*
    int array[100];
    for(int i=0; i<6; i++)
        scanf("%d",&array[i]);

    sort2(array);
    //sort5(array,0,5);

    for(int i=0; i<6; i++)
        printf("%d ",array[i]);
    return 0;
    */
    //输入数字从1开始
    int array[100];
    for(int i=1; i<7; i++)
        scanf("%d",&array[i]);
    sort7(array,6);
    for(int i=1; i<7; i++)
        printf("%d ",array[i]);
    return 0;
}


/*排序是按照从小到大的顺序进行排序*/

//直接插入排序
void sort1(int a[])
{
    int temp;
    for(int i=1; i<6; i++)
    {
        if(a[i]<a[i-1])
        {
            int j;
            temp = a[i];
            for(j=i-1; temp<a[j]; j-- )
                a[j+1] = a[j];
            a[j+1] = temp;
        }
    }
}

//折半插入排序
void sort2(int a[])
{
    int i,j,low,high,mid;
    int temp;
    for(i=1; i<6; i++){
        temp = a[i];
        low = 0;
        high = i - 1;
        while(low <= high)
        {
            mid = (low+high)/2;
            if(a[mid]>temp)
                high = mid -1;
            else
                low = mid + 1;
        }
        for(j=i-1; j>=high+1; j--)
            a[j+1] = a[j];
        a[high+1] = temp;
    }
}
//希尔排序
void sort3(int a[])
{
    int temp;
     for(int dk=6/2; dk>=1; dk/=2)
        for(int i=dk; i<=6; i++)
         {
            if(a[i]<a[i-dk])
            {
                temp = a[i];
                int j;
                for(j=i-dk; j>-1 && temp<a[j]; j-=dk)
                    a[j+dk] = a[j];
                a[j+dk] = temp;
            }
         }
}
//冒泡排序
void sort4(int a[])
{
    for(int i=0; i<6-1; i++)
    {
        for(int j=1; j<6-i; j++)
        {
            if(a[j]<a[j-1])
            {
                int t = a[j];
                a[j] = a[j-1];
                a[j-1] = t;
            }
        }
    }
}
//快速排序
int partition(int a[],int low,int high)
{
    int pivot=a[low];
    while(low<high)
    {
        while(low<high&&a[high]>=pivot)high--;
        a[low] = a[high];
        while(low<high&&a[low]<=pivot)low++;
        a[high] = a[low];
    }
    a[low] = pivot;
    return low;
}
void sort5(int a[],int low,int high)
{
    if(low<high){
        int pivotpos = partition(a,low,high);
        sort5(a,low,pivotpos-1);
        sort5(a,pivotpos+1,high);
    }
}
//简单选择排序
void sort6(int a[])
{
    for(int i=0; i<6-1; i++)
    {
        int min = i;
        for(int j=i+1; j<6; j++)
            if(a[j]<a[min])
                min=j;
        if(min != i)
        {
            int t = a[min];
            a[min] = a[i];
            a[i] = t;
        }
    }
}
//堆排
void adjustDown(int a[],int k,int len)
{
    a[0] = a[k];
    for(int i =2*k; i<=len; i*=2)
    {
        if(i<len && a[i]<a[i+1])
            i++;
        if(a[0]>=a[i]) break;
        else{
            a[k] = a[i];
            k = i;
        }
    }
    a[k] = a[0];
}
void buildMaxHeap(int a[],int len){
    for(int i=len/2; i>0; i--)
        adjustDown(a,i,len);
}
void sort7(int a[],int len)
{
    buildMaxHeap(a,len);
    for(int i = len; i>1; i--){                  //这个数组是从1开始的
            swap(a[i],a[1]);
            adjustDown(a,1,i-1);
    }
}

